# 12.6 참조에 의한 전달과 외부 상태의 변경

원시 값은 값에 의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference) 방식으로 동작한다.

함수 몸체 내부에서 매개변수는 변수와 동일하게 작동한다. 그래서 매개변수의 값에 의한 호출(call by value), 참조에 의한 호출(call by reference)의 작동방식은 값에 의한 전달과 참조에 의한 전달을 그대로 따른다.

## 왜 원시 값은 변하지 않고 객체 타입은 변했을까?

```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

// 외부 상태
var num = 100;
var person = { name: "Lee" };

console.log(num); // 100;
console.log(person); // { name: "Lee" }

// 원시 값은 값 자체가 복사되ㅓ 전달되고 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // { name: "Kim" }
```

위의 예시에서 함수는 매개변수를 통해 원시 타입 인수와 객체 타입 인수를 전달 받아 함수 몸체에서 변경한다.

여기까지 계속 공부해왔다면 제일 떠올려야 하는 게 있다. 원시 값은 변경이 불가능하다는 것, 객체는 참조(가리키기)에 의한 전달 방식으로 동작하기 때문에 값이 변할 수 있다는 것이다.

원시 타입 인수는 값 자체가 복사되서 매개변수로 전달된다. 함수 외부에서 함수 몸체 내부로 전달된 원시 값은 원본을 변경하는 부수 효과를 발생시키지 못한다.

반면 객체 타입 인수는 참조 값이 복사되어 매개변수로 전달된다. 함수 몸체 내부로 전달된 것은 참조 값이고 원본 객체가 변경되는 부수 효과가 발생해버린다.

## 원본 객체가 변경되지 않게 하려면?

객체의 상태 변경이 필요한 경우 객체의 방어적 복사(defensive copy)로 원본 객체를 완전히 복제(깊은 복사, deep copy)해서 새로운 객체를 생성하고 재할당을 하면 부수 효과를 피할 수 있다.

외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 순수 함수를 쓰는 프로그래밍 패러다임을 함수형 프로그램이라 한다. 부수 효과를 최대한 억제하고 오류를 피하면서 프로그램의 안정성을 높힌다.
