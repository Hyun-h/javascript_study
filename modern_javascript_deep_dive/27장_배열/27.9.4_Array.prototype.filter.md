# Array.prototype.filter

## 태초에 요구조건이 있었다.

1. 국가, 시/도, 시/군/구, 참가 매장으로 구성된 4개의 셀렉트 박스가 있다.
2. 이 셀렉트 박스에서 하나씩 선택하면 원하는 목록 하나가 나온다.  
   (예 : 대한민국, 서울시, 강북구, 행복한매장)
3. 모든 게 all 이면 매장 목록 전체가 출력되어야 한다.
4. 국가가 선택이 되면 해당 국가에 있는 매장 목록 전체가 출력이 되어야 한다.  
   (예 : 국가를 중국을 선택하면 중국의 전체 매장 목록이 나와야 함)
5. 국가, 시/도가 선택이 되고 시/군/구가 all이면 국가, 시/도의 매장 목록이 나와야 한다.  
   (예 : 서울시, 강북구의 전체 매장 목록이 나와야 함)

filter를 쓰면 풀릴 거 같아서 이리저리 코드를 만지다가 생각대로 풀리지 않았다.  
시간만 지나가고 풀리는 게 없어서 회사 상사 분께 코드리뷰를 부탁드렸는데, 코드리뷰 후 나온 코드는 이러했다.

```js
//불러온 매장 데이터를 변수에 담는다
let shopList = shopInfo.data;

if (country !== "all") {
  shopList = shopList.filter((p) => p.country === country);

  if (province !== "all") {
    shopList = shopList.filter((p) => p.provinceValue === province);

    if (city !== "all") {
      shopList = shopList.filter((p) => p.cityValue === city);
    }
  }
}
```

## 의문의 시작

```
filter가 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환하는데 (즉 filter 안에서 조건문이 돌고 있음) 왜 밖을 if문으로 감싸나요?
```

~~흐으음....?~~

코드리뷰 후 상단에 적은 제일 큰 의문점이 머리를 스쳐 지나가게 되었고, 코드 리뷰를 바탕으로 다시 수정해보았다.

```js
//불러온 매장 데이터를 변수에 담는다
let shopList = shopInfo.data;

if (country !== "all") shopList = shopList.filter((p) => p.country === country);
if (country !== "all" && province !== "all")
  shopList = shopList.filter((p) => p.provinceValue === province);
if (country !== "all" && province !== "all" && city !== "all")
  shopList = shopList.filter((p) => p.cityValue === city);
```

### 이게 최선인가요?

#### 문제점

1. 요구조건은 긍정문인데 막상 들어간 조건은 부정이다.
2. filter는 콜백함수를 판별하는 말 그대로 참거짓을 판별하는 조건문이 들어간다. 굳이 조건문이 필요한가?
3. filter는 원본 배열을 변경하지 않고 새로운 배열을 내뱉어서 let이 아닌 const로 처리가 가능할 거 같다.

## 해결

사실 나 혼자 해결을 하지는 못했다.  
회사에서 물어볼 프론트엔드 선임도 없어서 모던 자바스트립트와 MDN을 뒤져보고 여러 프론트엔드 분들께 조언을 구한 결과 아래와 같은 코드를 짤 수 있었고 요구조건도 충족할 수 있었다.

```js
const shopLIst = shopInfo.data
  //국가 필터링
  .filter((p) => country === "all" || p.country === country)
  //시/도 필터링
  .filter((p) => province === "all" || p.province === province)
  //시/군/구 필터링
  .filter((p) => city === "all" || p.city === city);

//필터링에 맞는 매장리스트가 나온다.
console.log(shopList);
```

### 마음을 불편하게 한 것을 개선해보자!

1. 요구조건은 긍정문인데 막상 들어간 조건은 부정이다.  
    처음 코드를 짤 때 요구 조건은 긍정(어떠한 조건이 all이면 조건에 맞는 걸 뽑아주세요~)인데 조건문에 들어간 조건은 부정이었다.(어떠한 조건이 all이 아니면 조건에 맞는 걸 뽑아주세요~)  
    그래서 조건을 어떠한 조건이 all이면 조건에 맞는 걸 뽑아주세요! 로 변경하였다.

   ```js
   //변경 전
   if (country !== "all")
     shopList = shopList.filter((p) => p.country === country);

   //변경 후
   const shopLIst = shopInfo.data.filter(
     (p) => country === "all" || p.country === country
   );
   ```

2. filter는 콜백함수를 판별하는 말 그대로 참거짓을 판별하는 조건문이 들어간다. 굳이 조건문이 필요한가?  
    아마도 코드를 짤 때 조건이 들어가야 한다는 것에만 꽂혀서 filter의 본질적인 이용 방법에 대해서 집중하지 못했던 거 같다. 처음 코드를 짤 때 filter 안에 콜백함수에서 또 조건을 넣으려고 그랬는데,

   ```js
   //부끄럽게도 이렇게 짜려고 했었다.
   const shopLIst = shopInfo.data.filter((p) => {
     if (country === "all") {
       //어쩌구 저쩌구
     }
   });
   ```

   필터 내에서는 하나의 조건만 들어가야 한다는 걸 다른 개발자 분의 코드리뷰로 알게 되었다.  
   그래서 아래와 같이 코드를 짜보았다.

   ```js
   const shopLIst = shopInfo.data
     //우리에게는 스위치처럼 쓸 수 있는 or 이라는 연산자가 있다.
     //국가가 all이면 전체 매장 리스트 보여주거나 필터된 국가의 매장 배열을 뱉어주십쇼!
     .filter((p) => country === "all" || p.country === country)
     //국가를 필터한 후, 다음 조건 실행.
     //시/도가 all이면 시/도 전체 매장 리스트를 보여주거나 필터된 시/도의 매장 배열을 뱉어주십쇼!
     .filter((p) => province === "all" || p.province === province)
     //시/도를 필터한 후, 다음 조건 실행.
     //시/군/구가 all이면 시/군/구 전체 매장 리스트를 보여주거나 필터된 시/군/구의 매장 배열을 뱉어주십쇼!
     .filter((p) => city === "all" || p.city === city);
   ```

3. filter는 원본 배열을 변경하지 않고 새로운 배열을 내뱉어서 let이 아닌 const로 처리가 가능할 거 같다.  
   const는 재할당이 금지되어 있다. 하지만 const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다. 이 경우에도 그런거지 않을까 싶어서 let에서 const로 변경하였고, 에러없이 예상은 적중하였다.
