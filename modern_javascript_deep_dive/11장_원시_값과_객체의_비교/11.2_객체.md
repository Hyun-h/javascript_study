# 11.2 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정할 수 앖다. 프로퍼티 개수와 값에 제약이 없고, 동적으로 추가되고 삭제할 수 있기 때문이다.

객체는 복잡한 자료구조로 원시 값에 비교해 복잡하고 구현 방식도 브라우저 제조사마다 다를 수 있다. 상대적으로 적은 메모리를 소비하는 원시 값과 다르게 객체는 경우에 따라 크기가 매우 클 수 있다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값에 비해 비용이 많이 들어간다.

그래서 객체는 원시 값과는 다른 방식으로 동작하게 설계되어 있다.

## 변경 가능한 값

객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

객체는 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값(reference value)을 통해 실체 객체에 접근한다.

- 참조 값 : 생성된 객체가 저장된 메모리 공간의 주소 그 자체

객체를 변수에 할당할 때 "변수는 객체를 참조하고 있다" 또는 "변수는 객체를 가리키고(point) 있다"고 표현한다.

변수는 그저 객체를 가리키고 있기에 객체를 변경할 수 있다. 객체를 할당한 변수는 재할당 없이 객체를 직접 변경한다. 재할당 없이 프로퍼티를 동적으로 추가하고, 프로퍼티 값을 갱신하고, 프로퍼티 자체를 삭제할 수 있다.

```js
var person = {
  name: "Lee",
};

// 프로퍼티 값 갱신
person.name = "Kim";

// 프로퍼티 동적 생성
person.address = "Seoul";

console.log(person); //{name: 'Kim', address: 'Seoul'}
```

### 왜 변경이 가능할까?

객체는 생성하고 관리하는 방식이 매우 복잡하다. 원시 값처럼 객체를 변경할 때마다 이전 값을 복사해서 새롭게 생성한다면 원시 값처럼 크기가 일정하지 않고 프로퍼티 값이 객체일 수 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다.  
메모리를 효율적으로 사용하고 객체를 복사해 생성시키는 비용을 절약하여 성능을 향상시키기 위해 변경 가능한 값으로 설계되어 있다.

## 참조에 의한 전달

객체가 변경이 가능하게 설계되어 있는 건 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 부작용이 있다. 이 소리는 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다는 뜻이다.

왜 이러는걸까?  
식별자들이 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 즉 메모리 주소는 달라도 식별자들이 동일한 객체를 가리키고 있다.

```js
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사). copy와 person은 동일한 참조 값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = "Kim";

// person을 통해 객체를 변경한다.
person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name: 'Kim', address: 'Seoul'}
console.log(copy); // {name: 'Kim', address: 'Seoul'}
```
