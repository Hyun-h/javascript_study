# 2.8 과거 습관을 새롭게

## var 대신 const, let 사용

### 과거 습관 : var 사용

var에 대한 유일한 나머지 사용 사례는 레거시 코드다.  
예를 들어 페이지에 로드될 수 있는 여러 스크립트에서 최상위 레벨이

```js
var MyApp = MyApp || {};
```

이고 모두 MyApp 객체의 다른 부분에기록된다면, 이를 수행하는 작업은 모듈로 대체된다.

### 새로운 습관 : const, let 사용

변경하지 않으려는 "변수"에 const를 채태갛면 원래 생각했던 것보다 훨씬 더 많이 const를 사용한다.  
특히 객체 참조를 사용할 경우 변경할 수 없다는 의미는 아니다.  
객체의 상태는 상수가 참조하는 객체가 변경할 수 없음을 의미한다.  
객체가 많은 코드를 작성하는 경우 실제 변수는 얼마되지 않는다.

## 변수 범위를 좁게 유지

### 과거 습관

함수의 맨 위에 var를 나열하는 것

### 새로운 습관

합리적이라면 가장 좁은 범위에서 let과 const를 사용한다.  
이는 코드의 유지 보수성을 향상시킨다.

## 인라인 익명 함수 대신 블록 스코프 사용

### 과거 습관

인라인 익명 함수를 사용하여 루프 내 클로저 문제를 해결한다.

```js
for (var n = 0; n < 3; ++n) {
  (function (value) {
    setTimeout(function () {
      console.log(value);
    }, 10);
  })(n);
}
```

### 새로운 습관

대신 블록 스코프를 사용한다.

```js
for (let n = 0; n < 3; ++n) {
  setTimeout(function () {
    console.log(value);
  }, 10);
}
```

재사용 가능한 함수를 정당한 이유 없이 블록 스코프로 대체하지 말 것!

```js
// 재사용 가능하게 이름 지어진 함수를 사용해서 이미 아래와 같다면 함수 코드를 루프로 이동할 필요가 ㅇ벗다.

function delayedLog(msg, delay) {
  setTimeout(function () {
    console.log(msg);
  }, delay);
}
// ...나중에...
for (let n = 0; n < 3; ++n) {
  delayedLog(n, 10);
}
```

블록 스코프는 기능의 크기를 지정하는 대신 사용할 수 없지만 혼동되는 인라인 익명 기능을 제거하는 데 유용하다.

전역 변수 생성을 피하기 위해 전역 스코프에서 스코프 지정 함수를 사용하는 경우 이를 블록(또는 모듈)으로 대체할 수도 있다.  
블록은 if나 for와 같은 흐름 제어문에 연결될 필요가 없다.  
독립적으로 사용할 수 있으므로 범위 지정 기능은 범위 지정 블록이 될 수 있다.

```js
// 범위 블록
{
  let answer = 42; // 'answer'느나 블록 내에서 전역이 아니라 지역적이다.
  console.log(answer);
}
```
