# 2.4 호이스팅과 일시적 데드존

var 선언문은 호이스팅된다.  
var를 사용하면 변수를 선언하기 전에 사용할 수 있다.

```js
function example() {
  console.log(answer); // undefined
  answer = 42;
  console.log(answer); // 42
  var answer = 67;
}

example();
```

왜 var 선언만 함수의 맨 위로 올라간 것처럼 동작하고 초기화 부분(= 67 부분)은 그렇지 않을까?

이는 함수를 실행할 때 자바스크립트 엔진이 런타임 이전에 선언 단계에서 var 선언을 처리하고 필요한 변수를 생성하는 함수를 읽기 때문에 발생한다. 함수의 맨 위에 선언을 끌어올린다.(호이스트 한다.) 선언 단계와 동시에 초기화 단계를 진행하면서 undefined로 변수를 초기화한다.

그러나 이는 코드의 명백한 의도와 실제 효과가 일치하지 않는다.

---

let과 const는 코드의 단계별 실행에서 선언이 처리될 때까지 변수를 사용할 수 없다.

```js
function example() {
  answer = 42;
  console.log(answer); // ReferenceError: 'answer' is not defined
  let answer = 67;
}

example();
```

var 선언처럼 let 선언이 함수의 제일 위로 올라가지 않는 것처럼 보이는 것 때문에 호이스팅이 일어나지 않는 것처럼 보인다.  
만약 let 선언이 호이스팅이 일어나지 않는다면 아래의 예시에서 answer는 외부에 할당되어야 하지만 그렇지 않다.

```js
let answer; // 외부 answer
function hoisting() {
  answer = 42; // ReferenceError: 'answer' is not defined
  console.log(answer);
  let answer; // 내부 answer
}
hoisting();
```

let과 const는 임시 데드존(Temporal Dead Zone, TMZ. 일시적 사각지대)라는 개념을 사용한다.  
TDZ는 실행되는 코드 실행 내에서 식별자를 전혀 사용할 수 없는 기간이다. 포함된 범위의 엔트리를 참조하는 데도 사용되지 않는다.  
var와 마찬가지로 자바스크립트 엔진은 코드의 단계별 실행을 하기 전에 let과 const 선언에 대한 코드를 살펴보고 처리한다.

```js
let answer; // 외부 answer
function notInitializedYet() {
  // 여기에 answer를 예약해 둔다
  answer = 42; // ReferenceError: 'answer' is not defined
  console.log(answer);
  let answer; // 내부 answer
}
notInitializedYet();
```
