# 2.7 루프의 블록 스코프

블록 내에서 let, const로 선언된 변수는 블록 내에서만 접근할 수 있다.

```js
function anotherBlockExample(str) {
  if (str) {
    let index = str.indexOf("x"); // 'index'는 블록 내에서만 존재한다.
    if (index !== -1) {
      str = str.substring(0, index);
    }
  }
  // 여기서 'index'를 사용할 수 없다. 블록 외부이다.
  return str;
}
anotherBlockExample();
```

루프 반복에서 함수에 대한 다른 호출은 각각 고유한 지역 변수를 얻는 것과 거의 똑같은 방식으로 고유한 블록 변수를 얻는다.  
블록 스코프를 사용하면 고전적인 "루프 내 클로저" 문제를 해결할 수 있다.

## "루프 내 클로저" 문제

이 코드는 1, 2, 3을 출력할 것이라 예상한 것과 다르게 4, 4, 4를 출력한다.

```js
function closuresInLoopsProblem() {
  for (var counter = 1; counter <= 3; ++counter) {
    setTimeout(function () {
      console.log(counter);
    }, 10);
  }
}

closuresInLoopsProblem();
```

루프가 끝날 때까지 각 타이머가 콜백을 실행하지 않았기 때문에 콜백을 호출할 때까지 counter의 값은 4이고 var로 선언되었기 때문에 counter는 함수 전체에 정의가 되었다.  
세 타이머 콜백은 모두 동일한 counter 변수로 감싸져 모두 값이 4가 나온다.

### 해결 방법 : ES5와 이전 버전

다른 함수를 도입하고 counter를 인수로 전달한 다음 console.log에서 counter 대신 해당 인수를 사용한다.

```js
function closuresInLoopsES5() {
  for (var counter = 1; counter <= 3; ++counter) {
    // 즉시 실행함수
    (function (value) {
      // 익명 함수의 시작
      setTimeout(function () {
        console.log(value);
      }, 10);
    })(counter); // 끝에 counter를 넘겨 호출한다.
  }
}

closuresInLoopsES5();
```

이를 실행하면 counter가 아닌 value 사용하기 때문에 예상되는 1, 2, 3을 출력하고 익명 래프 함수에 대한 각 호출은 타이머 함수가 종료될 자체 매개변수인 value를 가져온다.  
매개변수는 변경되지 않으므로 콜백은 예상 값을 출력한다.

### let으로 해결

하지만 let은 훨씬 더 간단하게 문제를 해결할 수 있다.

```js
function closuresInLoopsWithLet() {
  for (let counter = 1; counter <= 3; ++counter) {
    setTimeout(function () {
      console.log(counter);
    }, 10);
  }
}

closuresInLoopsWithLet();
```

루프에서 생성된 타이머 함수에 대해 루프 반복마다 하나씩 여러 counter 변수를 생성한다.  
따라서 각 반복은 자체 counter 변수를 갖는다.
