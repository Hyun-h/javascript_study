# 2.7 루프의 블록 스코프

블록 내에서 let, const로 선언된 변수는 블록 내에서만 접근할 수 있다.

```js
function anotherBlockExample(str) {
  if (str) {
    let index = str.indexOf("x"); // 'index'는 블록 내에서만 존재한다.
    if (index !== -1) {
      str = str.substring(0, index);
    }
  }
  // 여기서 'index'를 사용할 수 없다. 블록 외부이다.
  return str;
}
anotherBlockExample();
```

루프 반복에서 함수에 대한 다른 호출은 각각 고유한 지역 변수를 얻는 것과 거의 똑같은 방식으로 고유한 블록 변수를 얻는다.  
블록 스코프를 사용하면 고전적인 "루프 내 클로저" 문제를 해결할 수 있다.

## "루프 내 클로저" 문제

이 코드는 1, 2, 3을 출력할 것이라 예상한 것과 다르게 4, 4, 4를 출력한다.

```js
function closuresInLoopsProblem() {
  for (var counter = 1; counter <= 3; ++counter) {
    setTimeout(function () {
      console.log(counter);
    }, 10);
  }
}

closuresInLoopsProblem();
```

루프가 끝날 때까지 각 타이머가 콜백을 실행하지 않았기 때문에 콜백을 호출할 때까지 counter의 값은 4이고 var로 선언되었기 때문에 counter는 함수 전체에 정의가 되었다.  
세 타이머 콜백은 모두 동일한 counter 변수로 감싸져 모두 값이 4가 나온다.

### 해결 방법 : ES5와 이전 버전

다른 함수를 도입하고 counter를 인수로 전달한 다음 console.log에서 counter 대신 해당 인수를 사용한다.

```js
function closuresInLoopsES5() {
  for (var counter = 1; counter <= 3; ++counter) {
    // 즉시 실행함수
    (function (value) {
      // 익명 함수의 시작
      setTimeout(function () {
        console.log(value);
      }, 10);
    })(counter); // 끝에 counter를 넘겨 호출한다.
  }
}

closuresInLoopsES5();
```

이를 실행하면 counter가 아닌 value 사용하기 때문에 예상되는 1, 2, 3을 출력하고 익명 래프 함수에 대한 각 호출은 타이머 함수가 종료될 자체 매개변수인 value를 가져온다.  
매개변수는 변경되지 않으므로 콜백은 예상 값을 출력한다.

### let으로 해결

하지만 let은 훨씬 더 간단하게 문제를 해결할 수 있다.

```js
function closuresInLoopsWithLet() {
  for (let counter = 1; counter <= 3; ++counter) {
    setTimeout(function () {
      console.log(counter);
    }, 10);
  }
}

closuresInLoopsWithLet();
```

루프에서 생성된 타이머 함수에 대해 루프 반복마다 하나씩 여러 counter 변수를 생성한다.  
따라서 각 반복은 자체 counter 변수를 갖는다.

## 바인딩: 변수, 상수, 기차 식별자의 작동 방식

const와 let은 범위, 보유할 수 있는 값의 종류 등의 관점에서 동일하게 동작한다.  
왜 그럴까?

내부적으로 변수와 상수는 사양에서 동일하게 바인딩(이 경웨서는 식별자 바인딩)이라고 부른다.  
이는 식별자와 해당 값에 대한 저장소 간의 연결이다.

```js
let x = 42;
```

위의 예시의 경우 x라는 식별자에 대한 바인딩을 만들고 해당 바인딩의 저장소 슬롯에 값 42를 저장한다.  
이 경우 변경 가능한 바인딩(값이 변경될 수 있는 바인딩)이다.  
상수를 만들 때 변경할 수 없는 바인딩(값을 변경할 수 없는 바인딩)을 만든다.

식별자 바인딩에는 이름과 값이 있다.  
이는 객체 속성과 비슷하다.  
객체 속성과 마찬가지로 컨테이너가 있으며 환경 객체라 부른다.

```js
let a = 42;
const b = 2;
```

위의 코드의 실행 컨텍스트 환경 객체는 아래와 비슷하게 바인딩된다.

```
환경 객체

이름: "a"
값: 1
종류: 식별자
변경 가능 여부: true

---

이름: "b"
값: 2
종류: 식별자
변경 가능 여부: false
```

환경 객체는 중첩된 범위를 처리하기 위해 체인으로 함께 연결된다.  
각 객체는 "외부" 객체에 대한 링크가 있다.  
코드에서 현재 환경 객체에 없는 식별자가 필요할 때 외부 환경 객체에 대한 링크를 따라가 찾는다.(전역 변수가 작동하는 방식인 전역 환경을 통해 필요에 따라 반복된다.)

예를 들어 "루프 내 클로저" 문제에서 루프의 블록 스코프 메커니즘은 ES5 솔루션의 익명 함수가 수행한 작업을 정확하게 수행했다.  
각 타이머 함수에 별도의 함수와 함수 호출없이 바인딩의 자체 복사본으로 감쌀 수 없는 다른 환경 객체를 제공했다.

블록이 자체 환경 객체를 얻는 것은 for 루프에만 해당되지 않는다.  
while과 do-while 루프에서도 자체 환경 객체를 얻는 블록의 이점을 얻을 수 있다.

## while과 do-while 루프

이 둘은 for의 초기화 표현식이 없기 때문에 거기에 선언된 바인딩 값을 복사하는 작업은 수행하지 않는다.  
하지만 각 루프 반복과 연관된 블록은 여전히 자체 환경을 갖는다.

## 성능 영향

루프에서 블록 변수를 사용할 때 이를 보유하고 체인을 설정하고 for 루프의 경우 복사할 새 환경 객체를 만들어야 하고 어딘가에서 어딘가로 반복 바인딩 값을 복사해야 한다고 루프 속도가 느려지지 않을까?

1. 성급한 최적화는 성급하다. 실제 성능에 문제가 생겨 해결해야 한다면 생각하자.
2. 그럴수도 있고 아닐수도 있다. 자바스크립트 엔진이 최적화하지 않았고 최적화할 수 없는 경우 확실히 더 많은 오버 헤드가 발생한다. 하지만 최신 엔진은 많은 최적화를 한다.

만약 루프에 실제 문제가 발생하고 변수의 별도 사본이 있는 것이 중요하지 않은 경우, 둘러싼 범위로 이동하자.

```js
let n;
for (n = 0; n < aReallyReallyBigNumber; ++n) {
  // ...
}
```

또는 해당 범위에서 원하지 않는 경우 전체 루프를 익명 블록으로 래핑하고 해당 블록에 변수를 선언하자.

```js
function wrappingInAnonymousBlock() {
  // ...관련 없는 코드...

  // 이제 우리는 반복당 'n' 초기화하는 성능/메모리 문제를 식별했다.
  // 그래서 익명 블록을 사용하여 단 하나의 'n'을 갖게 한다.
  {
    let n;
    for (n = 0; n < aReallyReallyBigNumber; ++n) {
      // ...
    }
  }
  // ...관련 없는 코드...
}
wrappingInAnonymousBlock();
```

## 루프 블록에서 const

루프 블록 내의 값은 절대 변경되지 않는다.  
각 블록은 자체 사본을 가져오므로 범위 내에서 상수이며 const를 선언하여 수정하는 것이 아닌 사용하려는 의도를 표현할 수 있다.

변경하지 않는 이유만으로 const를 선언할 필요가 없다.  
변경 여부는 스타일의 문제이다.  
개발 중에 const를 사용하면 변경하려고 할 때 초기 오류가 나서 의도적으로 선언을 변경하거나 해당 상수의 값을 변경하지 않는 실용적인 이점이 있다.

## for-in 루프에서 const

초기화, 종료조건, 증감식, 본문이 있는 일반적인 for 루프 외에도 자바스크립트에는 다른 유형의 for 루프가 있다.

for-in에 대해 살펴보자면 ES2015+에서 작성하려는 경우 key에 let이나 const를 넣을 수 있다.  
for-in 루프는 while처럼 각 루프 반복에 대해 별도의 환경 객체를 얻는다.  
루프 본문의 코드는 키를 변경하지 않으므로 원하는 경우 const가 될 수 있다.
